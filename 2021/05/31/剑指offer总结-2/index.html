<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuzhang1108.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第二次总结4.重建二叉树题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回 示例：输入：[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]                返回值：{1,2,5,3,4">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer总结-2">
<meta property="og:url" content="http://xuzhang1108.github.io/2021/05/31/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-2/index.html">
<meta property="og:site_name" content="XuZhang&#96;s blog">
<meta property="og:description" content="第二次总结4.重建二叉树题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回 示例：输入：[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]                返回值：{1,2,5,3,4">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-31T07:09:28.000Z">
<meta property="article:modified_time" content="2021-06-14T08:54:01.134Z">
<meta property="article:author" content="XuZhang">
<meta property="article:tag" content="算法和数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xuzhang1108.github.io/2021/05/31/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>剑指offer总结-2 | XuZhang`s blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XuZhang`s blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuzhang1108.github.io/2021/05/31/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="XuZhang">
      <meta itemprop="description" content="海阔凭鱼跃，天高任鸟飞">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XuZhang`s blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指offer总结-2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-31 15:09:28" itemprop="dateCreated datePublished" datetime="2021-05-31T15:09:28+08:00">2021-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 16:54:01" itemprop="dateModified" datetime="2021-06-14T16:54:01+08:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法和数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第二次总结"><a href="#第二次总结" class="headerlink" title="第二次总结"></a>第二次总结</h1><h2 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">4.重建二叉树</a></h2><p><strong>题目</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
<p>示例：输入：[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]                返回值：{1,2,5,3,4,6,7}</p>
<p><strong>思路：</strong>前序遍历的特点是第一个遍历的结点是根结点。于是我们通过知道了根结点的值，可以在中序遍历找到根结点所在的位置，进而可以划分出树的左子树和右子树。然后根据划分出来的左右子树在进行这样的操作，即：在子树的前序遍历中第一个出现的是子树的根结点，根据子树根结点的值在子树的中序遍历中再次划分子树的左右子树，可见每一次操作都在重复着一个函数，因此，这是个递归过程。递归的终止条件就是遍历到叶子节点，返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">ConstructCore</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pre, vector&lt;<span class="hljs-keyword">int</span>&gt; vin)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>() || vin.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">int</span> rootVal = pre[<span class="hljs-number">0</span>];<br>    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>    <br>    <span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; vin.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;  <span class="hljs-comment">// 到达叶节点，直接返回</span><br>    <br>    <span class="hljs-keyword">int</span> seperate = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 确定根结点在中序遍历中的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vin.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (vin[i] == rootVal) &#123;<br>            seperate = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行左右子树的分割</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">vinLeft</span>(vin.<span class="hljs-built_in">begin</span>(), vin.<span class="hljs-built_in">begin</span>()+seperate);  <br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">vinRight</span>(vin.<span class="hljs-built_in">begin</span>()+seperate+<span class="hljs-number">1</span>, vin.<span class="hljs-built_in">end</span>());<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">preLeft</span>(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+seperate);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">preRight</span>(pre.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>+seperate, pre.<span class="hljs-built_in">end</span>()); <br>    <br>    <span class="hljs-comment">// 使用相同的函数重复进行上面的：1.检查是否到达叶结点 2.确定根结点在中序遍历中位置  3. 分割成左右子树  4.递归调用</span><br>    root-&gt;left = <span class="hljs-built_in">ConstructCore</span>(preLeft, vinLeft);<br>    root-&gt;right = <span class="hljs-built_in">ConstructCore</span>(preRight, vinRight);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pre,vector&lt;<span class="hljs-keyword">int</span>&gt; vin)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pre.<span class="hljs-built_in">empty</span>() || vin.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ConstructCore</span>(pre, vin);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="**17.树的子结构"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**17.树的子结构</a></h2><p><strong>题目：</strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>示例：输入：{8,8,#,9,#,2,#,5},{8,9,#,2}             输出：true</p>
<p><strong>思路：</strong>首先判断两个树的头结点是否相等，若两个树的头结点不等，就往下遍历第一棵树的结点。遍历到了下一个结点后再继续判断遍历到的结点是否和第二棵树的头结点是否相等。若相等调用函数DoesTree1HasTree2. 在DoesTree1HasTree2我们首先判断遍历到Tree2的结点是否为空，若为空的话，直接返回true；若Tree1为空，则返回false；若Tree1和Tree2的值不等，返回false。若上述条件都通过，则继续往下遍历Tree1和Tree2对应的结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DoesTree1HasTree2</span><span class="hljs-params">(TreeNode* p1, TreeNode* p2)</span> </span>&#123;<br>    <span class="hljs-comment">// if (p1-&gt;val != p2-&gt;val) return false;  若p1或p2是空的，这句就会报错了，因此应将该句放到两个判断是否为空的语句后面。</span><br>    <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (p1-&gt;val != p2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    <br>    <span class="hljs-keyword">bool</span> leftResult = <span class="hljs-built_in">DoesTree1HasTree2</span>(p1-&gt;left, p2-&gt;left);<br>    <span class="hljs-keyword">bool</span> rightResult = <span class="hljs-built_in">DoesTree1HasTree2</span>(p1-&gt;right, p2-&gt;right);<br>    <span class="hljs-keyword">return</span> leftResult &amp; rightResult;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (pRoot1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pRoot2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val) <br>        	ans = <span class="hljs-built_in">DoesTree1HasTree2</span>(pRoot1, pRoot2);<br>        <span class="hljs-keyword">if</span> (!ans)<br>            ans = <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2);<br>        <span class="hljs-keyword">if</span> (!ans)<br>            ans = <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);     <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="18-二叉树镜像"><a href="#18-二叉树镜像" class="headerlink" title="18.二叉树镜像"></a><strong><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">18.二叉树镜像</a></strong></h2><p>**题目:**操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">比如：    源二叉树 <br><span class="hljs-code">            8</span><br><span class="hljs-code">           /  \</span><br><span class="hljs-code">          6   10</span><br><span class="hljs-code">         / \  / \</span><br><span class="hljs-code">        5  7 9 11</span><br><span class="hljs-code">        镜像二叉树</span><br><span class="hljs-code">            8</span><br><span class="hljs-code">           /  \</span><br><span class="hljs-code">          10   6</span><br><span class="hljs-code">         / \  / \</span><br><span class="hljs-code">        11 9 7  5</span><br></code></pre></td></tr></table></figure>

<p>示例：输入：{8,6,10,5,7,9,11}                    输出：{8,10,6,11,9,7,5}</p>
<p><strong>思路：</strong>首先判断头结点是否为空。若为空直接返回，否则交换头结点左右两个孩子。交换完之后再继续遍历下一个结点（这里的遍历方式使用的是前序遍历）。下一个结点的操作方式同之前一样：1.判断是否为空   2. 交换两个子结点   3.遍历到下一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-built_in">swap</span>(pRoot-&gt;left, pRoot-&gt;right);<br>    <br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>    <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>    <span class="hljs-keyword">return</span> pRoot;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">22.从上往下打印二叉树</a></h2><p><strong>题目：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>示例：输入：{5,4,#,3,#,2,#,1}                输出：[5,4,3,2,1]</p>
<p><strong>思路：</strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。显然这是让你实现二叉树结构的层序遍历。二叉树的层序遍历利用队列的先进先出特性。压入一个结点后，将其拷贝给一个临时结点。然后将其从队列中移除。在判断被移除结点的左右子结点是否为空，若不为空将其分别压入到队列中。循环此过程直至队列为空的时候。我们停止，直接返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;<br>	queue&lt;TreeNode*&gt;q;<br>	q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode *tempNode = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>        <span class="hljs-keyword">if</span> (tempNode-&gt;left != <span class="hljs-literal">nullptr</span>) <br>            q.<span class="hljs-built_in">push</span>(tempNode-&gt;left);<br>        <span class="hljs-keyword">if</span> (tempNode-&gt;right != <span class="hljs-literal">nullptr</span>)<br>            q.<span class="hljs-built_in">push</span>(tempNode-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="**23.二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**23.二叉搜索树的后序遍历序列</a></h2><p><strong>题目：</strong>输入一个整数数组，判断该数组是不是某二叉搜索树的<strong>后序遍历</strong>==(特点最后一个数值是根结点)==的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p>
<p>示例：输入：[4,8,6,12,16,14,10]            输出: true</p>
<p><strong>思路：</strong> 根据找到的根结点来分割数组，因为二叉搜索树中左子树的值都小于根结点的值，右子树的值都大于根结点的值，如果我们在遍历右子树的过程中发现有比根结点值小的数，立即返回false。若上面顺利通过说明前面都是符合BST的，因此我们初始化 bool left = true;  bool right = true;   如果左子树或者右子树存在结点，我们对其进行前面相同的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sequence.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> len = sequence.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> rootVal = sequence[len<span class="hljs-number">-1</span>];<br>    <br>    <span class="hljs-comment">// 找到左子树</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (sequence[i] &gt; rootVal)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到右子树</span><br>    <span class="hljs-keyword">int</span> j = i;<br>    <span class="hljs-keyword">for</span> (; j &lt; len<span class="hljs-number">-1</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (sequence[j] &lt; rootVal)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(sequence.begin(), sequence.begin()+i)</span></span>;<br>    sequence.<span class="hljs-built_in">resize</span>(len<span class="hljs-number">-1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(sequence.begin()+i, sequence.end())</span></span>;<br>    <br>    <span class="hljs-keyword">bool</span> ans1 = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>    	ans1 = <span class="hljs-built_in">VerifySquenceOfBST</span>(left);<br>    <span class="hljs-keyword">bool</span> ans2 = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (i &lt; len<span class="hljs-number">-1</span>)<br>    	ans2 = <span class="hljs-built_in">VerifySquenceOfBST</span>(right);<br>    <span class="hljs-keyword">return</span> ans1 &amp;&amp; ans2;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="24-二叉树中和为某一值得路径"><a href="#24-二叉树中和为某一值得路径" class="headerlink" title="**24.二叉树中和为某一值得路径"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**24.二叉树中和为某一值得路径</a></h2><p><strong>题目：</strong>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>示例：输入：{10,5,12,4,7},22        输出：[[10,5,7],[10,12]]                    输入：{10,5,12,4,7},15            输出：[]</p>
<p><strong>思路：</strong>遍历整棵树，并记录经过的结点和累加的总和。当累加的总和等于target并且结点是叶子结点时将其加入到结果当中。因为已经是叶子节点了，所以我们不需要再继续往下遍历了操作，而是需要进行回溯的操作（删除数组的尾部元素并将求和的sum值减去叶子结点的值）。 如果前面所说的累加的总和不等于target并且结点不是叶子结点的话我们继续遍历，直到遍历完整棵树，结束递归的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backTrace</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    sum += root-&gt;val;<br>    path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-keyword">bool</span> isLeaf = root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (sum == target &amp;&amp; isLeaf) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(path);<br>    &#125;<br>	<span class="hljs-keyword">if</span> (root-&gt;left)<br>    	<span class="hljs-built_in">backTrace</span>(root-&gt;left, sum, target);<br>    <span class="hljs-keyword">if</span> (root-&gt;right)<br>        <span class="hljs-built_in">backTrace</span>(root-&gt;right, sum, target);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    sum -= root-&gt;val;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">FindPath</span>(TreeNode* root,<span class="hljs-keyword">int</span> expectNumber) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">backTrace</span>(root, <span class="hljs-number">0</span>, expectNumber);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="**26.二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**26.二叉搜索树与双向链表</a></h2><p><strong>题目</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个<strong>排序的双向链表</strong>。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p><strong>思路</strong>：看到<strong>二叉搜索树</strong>和<strong>排序</strong>联系到二叉搜索树的中序遍历。二叉搜索树中序遍历后的序列是升序的。既然排序成双向链表，那么我们首先创建个虚拟头结点并初始化为NULL。双向链表那就得有前后两个指针，我们就用 left指针 代替 next指针，right指针 代替 pre指针。如果遍历开始，那么我们应将遍历到的第一个结点的 left指针 指向NULL（即指向我们创建的虚拟头结点），然后判断我们的虚拟头结点是否为空，不为空的话，为其指定 right指针。否则直接跳过将虚拟头结点移动到当前指针。直至遍历完整棵树。此时我们的虚拟头结点已经变成尾结点了，如果我们要向 输出链表的话，我们得将虚拟头结点在移动到头部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConvertCore</span><span class="hljs-params">(TreeNode* root, TreeNode** ListNode)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">ConvertCore</span>(root-&gt;left, ListNode);<br>    TreeNode* currentNode = root;<br>    currentNode-&gt;left = *ListNode;<br>    <span class="hljs-keyword">if</span> (*ListNode != <span class="hljs-literal">nullptr</span>)<br>        *ListNode-&gt;right = currentNode;<br>    *ListNode = currentNode;<br>    <br>    <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">ConvertCore</span>(root-&gt;right, ListNode);<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>    TreeNode* ListNodeHead = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">ConverCore</span>(pRootOfTree, &amp;ListNodeHead);<br>    <span class="hljs-keyword">while</span> (ListNodeHead != <span class="hljs-literal">nullptr</span> &amp;&amp; ListNodeHead-&gt;left != <span class="hljs-literal">nullptr</span>)<br>        ListNodeHead = ListNodeHead-&gt;left;<br>    <span class="hljs-keyword">return</span> ListNodeHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">29.最小的K个数</a></h2><p>题目：给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p>
<p>示例：输入：[4,5,1,6,2,7,3,8],4             输出：[1,2,3,4]</p>
<p>思路：利用快速排序将无序数组变成有序，再看快排选用的那个数字位于数组的什么位置。如果快排选用的数字位于k-1的前面，我们将start位置设置成ret+1.如果快排选用的数字位于k-1的后面，我们将end位置设置成ret-1。直到ret == k-1，退出循环，返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RandomNumOfRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> randNum = <span class="hljs-built_in">rand</span>() % (end - start + <span class="hljs-number">1</span>) + start;<br>    <span class="hljs-keyword">return</span> randNum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; input, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> small = start - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">RandomNumOfRange</span>(start, end);<br>    <br>    <span class="hljs-built_in">swap</span>(input[index], input[end]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) &#123;<br>        <span class="hljs-keyword">if</span> (input[i] &lt; input[end]) &#123;<br>            small++;<br>            <span class="hljs-keyword">if</span> (small != i)<br>                <span class="hljs-built_in">swap</span>(input[i], input[small]);<br>        &#125;     <br>    &#125;<br>    <br>    ++small;<br>    <span class="hljs-built_in">swap</span>(input[small], input[end]);<br>    <span class="hljs-keyword">return</span> small;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">empty</span>() || k &gt; input.<span class="hljs-built_in">size</span>() || k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = input.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">Partition</span>(input, start, end);<br>    <span class="hljs-keyword">while</span> (ret != k<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ret &lt; k<span class="hljs-number">-1</span>) &#123;<br>            start = ret + <span class="hljs-number">1</span>;<br>            ret = <span class="hljs-built_in">Partition</span>(input, start, end);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            end = ret - <span class="hljs-number">1</span>;<br>            ret = <span class="hljs-built_in">Partition</span>(input, start, end);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">ans</span>(input.<span class="hljs-built_in">begin</span>(), input.<span class="hljs-built_in">begin</span>()+k);<br>   	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&&tqId=11183&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">30.连续子数组的最大和</a></h2><p><strong>题目</strong>：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>示例：输入：[1,-2,3,10,-4,7,2,-5]            返回值：18</p>
<p>说明：输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4,7,2}，因此输出为该子数组的和 18。 </p>
<p><strong>思路：</strong>从前往后遍历顺序相加。我们设置个变量maxSum来记录最大值，等我们的累加sum大于maxSum时候，我们就更新maxSum。如果再累加的过程中我们发现累加和居然比当前累加的数值都小，那么我们将当前的累加和设置为当前的累加值。在循环往复此过程直至整个数组都遍历完，结束此过程，返回maxSum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxSum = INT_MIN;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        sum += array[i];<br>        <span class="hljs-keyword">if</span> (sum &lt;= array[i])<br>            sum = array[i];<br>        <span class="hljs-keyword">if</span> (sum &gt; maxSum) &#123;<br>            maxSum = sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="31-整数中1出现的次数-从1到n整数中1出现的次数"><a href="#31-整数中1出现的次数-从1到n整数中1出现的次数" class="headerlink" title="31.整数中1出现的次数(从1到n整数中1出现的次数)"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">31.整数中1出现的次数(从1到n整数中1出现的次数)</a></h2><p><strong>题目：</strong>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p>
<p>示例：输入：13                    输出：6</p>
<p><strong>思路：</strong> 普通idea如下：遍历每一个数字并通过 一个函数来统计该数字中有几个1, 最后累加每个数字包含1的个数。</p>
<p>​             <strong>进阶待续….</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timesOfOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> times = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n%<span class="hljs-number">10</span> == <span class="hljs-number">1</span>)<br>            times++;<br>        n = n / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> times;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        counter += <span class="hljs-built_in">timesOfOne</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="**32.把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**32.把数组排成最小的数</a></h2><p><strong>题目：</strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>示例：输入：[3,32,321]                输出：”321323”</p>
<p><strong>思路：</strong>调用sort库函数并给其指定排序规则，最后将排好序的数组中的每个数字转换成字符串再进行拼接，进而形成了输出结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>    <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b) &#123;<br>        string s1 = <span class="hljs-built_in">to_string</span>(a);<br>        string s2 = <span class="hljs-built_in">to_string</span>(b);<br>        <span class="hljs-keyword">return</span> s1+s2 &lt; s2+s1;<br>    &#125;);    <span class="hljs-comment">// 对数组按照设计的匿名函数进行排序。</span><br>    <br>    string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        ans += <span class="hljs-built_in">to_string</span>(numbers[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">33.丑数</a></h2><p><strong>题目：</strong>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>示例：输入：7                             输出：8</p>
<p><strong>思路：</strong>根据丑数只包含质因子2、3和5的特性，我们可以创建一个丑数数组，然后通过索引第N个数进行返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> num3)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minVal = num1 &lt; num2 ? num1 : num2;<br>    <span class="hljs-keyword">return</span> minVal &lt; num3 ? minVal : num3;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ugly</span><span class="hljs-params">(index+<span class="hljs-number">1</span>)</span></span>;<br>    ugly[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> twoIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> threeIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fiveIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= index; i++) &#123;<br>        <span class="hljs-keyword">int</span> minVal = <span class="hljs-built_in">Min</span>(<span class="hljs-number">2</span>*ugly[twoIndex], <span class="hljs-number">3</span>*ugly[threeIndex], <span class="hljs-number">5</span>*ugly[fiveIndex]);<br>        ugly[i] = minVal;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * ugly[twoIndex] &lt;= ugly[i])<br>            twoIndex++;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">3</span> * ugly[threeIndex] &lt;= ugly[i])<br>            threeIndex++;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">5</span> * ugly[fiveIndex] &lt;= ugly[i])<br>            fiveIndex++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ugly[index<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="34-第一个只出现一次的字符位置"><a href="#34-第一个只出现一次的字符位置" class="headerlink" title="34.第一个只出现一次的字符位置"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&&tqId=11187&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">34.第一个只出现一次的字符位置</a></h2><p><strong>题目：</strong>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>示例：输入：”google”                输出：4</p>
<p><strong>思路：</strong> 利用哈希表记录每个字符出现的次数，然后遍历哈希，遇到数值为1退出，返回对应的i值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> tableSize = <span class="hljs-number">256</span>;<br>    <span class="hljs-keyword">int</span> hashTable[tableSize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tableSize; i++) &#123;<br>        hashTable[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        hashTable[str[i]]++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (hashTable[str[i]] == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="36-两个链表的第一个公共节点"><a href="#36-两个链表的第一个公共节点" class="headerlink" title="36.两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">36.两个链表的第一个公共节点</a></h2><p><strong>题目：</strong>输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p><strong>思路：</strong>先计算连个链表的长度，计算出长的比短的长多少，然后让长的先走长出来的几个结点的长度。当走完后我们同时遍历两个链表，当两个链表的结点相同时就说明此结点是公共结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>        len++;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span> || pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-keyword">int</span> len1 = <span class="hljs-number">0</span>, len2 = <span class="hljs-number">0</span>;<br>    ListNode* p1 = pHead1, *p2 = pHead2;<br>   	<br>    len1 = <span class="hljs-built_in">getLength</span>(p1);<br>    len2 = <span class="hljs-built_in">getLength</span>(p2);<br>    <br>    <span class="hljs-keyword">if</span> (len1 &gt; len2) &#123;<br>        <span class="hljs-keyword">int</span> gap = len1 - len2;<br>        <span class="hljs-keyword">while</span> (gap-- ) <br>            pHead1 = pHead1-&gt;next;<br>        <span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-literal">nullptr</span> || pHead2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pHead1-&gt;val == pHead2-&gt;val)<br>                <span class="hljs-keyword">return</span> pHead2;<br>            pHead1 = pHead1-&gt;next;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> gap = len2 - len1;<br>        <span class="hljs-keyword">while</span> (gap-- ) <br>            pHead2 = pHead2-&gt;next;<br>        <span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-literal">nullptr</span> || pHead2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pHead1-&gt;val == pHead2-&gt;val)<br>                <span class="hljs-keyword">return</span> pHead2;<br>            pHead1 = pHead1-&gt;next;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="**37.数字在排序数组中出现的次数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**37.数字在排序数组中出现的次数</a></h2><p><strong>题目：</strong>统计一个数字在升序数组中出现的次数。</p>
<p>示例：输入：[1,2,3,3,3,3,4,5],3                        输出：4</p>
<p><strong>思路：</strong>通过两个函数来找到数字在数组中第一次出现的位置和数字在数组中最后一次出现的位置，进而就找到了数字出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetFirstK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> midIndex = (start + end) / <span class="hljs-number">2</span>;<br>  <br>    <span class="hljs-keyword">if</span> (data[midIndex] == k) &#123;<br>        <span class="hljs-keyword">if</span> (data[midIndex<span class="hljs-number">-1</span>] != k) || midIndex == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> midIndex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            end = midIndex - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[midIndex] &lt; k) &#123;<br>        start = midIndex + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        end = midIndex - <span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">GetNumberOfK</span>(data, k, start, end);       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLastK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> midIndex = (start + end) / <span class="hljs-number">2</span>;<br>  <br>    <span class="hljs-keyword">if</span> (data[midIndex] == k) &#123;<br>        <span class="hljs-keyword">if</span> (data[midIndex+<span class="hljs-number">1</span>] != k) || midIndex == data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> midIndex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            start = midIndex + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[midIndex] &lt; k) &#123;<br>        start = midIndex + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        end = midIndex - <span class="hljs-number">1</span>;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">GetNumberOfK</span>(data, k, start, end);       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> firstK = <span class="hljs-built_in">GetFirstK</span>(data, k, start, end);<br>    <span class="hljs-keyword">int</span> lastK = <span class="hljs-built_in">GetLastK</span>(data, k, start, end);<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (firstK &gt; <span class="hljs-number">-1</span> &amp;&amp; lastK &gt; <span class="hljs-number">-1</span>) &#123;<br>        ans = lastK - firstK + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">38.二叉树的深度</a></h2><p><strong>题目：</strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>示例：输入：{1,2,3,4,5,#,6,#,#,7}                  输出：4</p>
<p><strong>思路：</strong> 利用二叉树的先序遍历也即深度优先搜索，遍历到叶子结点之后深度加1，然后开始往上返回。没返回一层深度加1。直到遍历了整棵树后，再返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> leftDepth = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>    <span class="hljs-keyword">int</span> rightDepth = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftDepth, rightDepth)+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<h2 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&&tqId=11193&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">40.数组中只出现一次的数字</a></h2><p><strong>题目：</strong>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>示例：输入：[1,4,1,6]                输出：[4,6]</p>
<p><strong>思路：</strong>利用哈希表记录相应的数值出现的次数，然后遍历哈希表，将出现次数为一的值放入到结果数组当中，返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;hashTable;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        hashTable[array[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> it = hashTable.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (hashTable[array[i]] == <span class="hljs-number">1</span>)<br>            ans.<span class="hljs-built_in">push_back</span>(array[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="41-和为S的连续整数序列"><a href="#41-和为S的连续整数序列" class="headerlink" title="**41.和为S的连续整数序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**41.和为S的连续整数序列</a></h2><p>题目：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的<strong>连续正数序列</strong>? Good Luck!</p>
<p>示例：输入：9                            输出：[[2,3,4],[4,5]]</p>
<p>思路：从头到尾遍历逐渐累加，如果累加和等于target 存入到结果中。如果累加和大于 target 我们将小值减去并移动小值所指的索引。如果减去小值后的结果等于target 我们将小值到大值的数字加入到结果当中。ps：循环退出的条件是当小值大于 target的一半就退出，因为此序列是升序。当 小值大于一半值的话，累加的和 肯定大于 target啊，所以我们不考虑 （1+sum）/ 2  之后的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-keyword">int</span> sum) &#123;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">int</span> small = <span class="hljs-number">1</span>, big = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> half = (<span class="hljs-number">1</span> + sum) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tempSum = small + big;<br>    <span class="hljs-keyword">while</span> (small &lt; half) &#123;<br>        <span class="hljs-keyword">if</span> (tempSum == sum) &#123;<br>            path.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = small; i &lt;= big; i++) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (tempSum &gt; sum &amp;&amp; small &lt; half) &#123;<br>            tempSum -= small;<br>            ++small;<br>            <br>            <span class="hljs-keyword">if</span> (tempSum == sum) &#123;<br>                path.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = small; i &lt;= big; i++) &#123;<br>                    path.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>        &#125;<br>        ++big;<br>        tempSum += big;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="42-和为S的两个数"><a href="#42-和为S的两个数" class="headerlink" title="42.和为S的两个数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">42.和为S的两个数</a></h2><p><strong>题目：</strong>输入一个<strong>递增排序</strong>的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的<strong>乘积最小</strong>的。</p>
<p>示例：输入：[1,2,4,7,11,15],15                    输出：[4,11]</p>
<p><strong>思路：</strong>通过双指针遍历数组，一个指向头部，另一个指向尾部。如果两个指针所指的数字相加的值大于target，尾部指针向前移动。如果两个指针的数字相加小于target，头部指针向后移动。否则的话，就是两个指针所指向的数字相加等于target，直接返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (head &lt; tail) &#123;<br>        <span class="hljs-keyword">if</span> (array[head]+array[tail] &gt; sum) &#123;<br>            tail--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[head] + array[tail] &lt; sum) &#123;<br>            head++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;array[head], array[tail]&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&&tqId=11196&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">43.左旋转字符串</a></h2><p><strong>题目：</strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>示例：输入：”abcXYZdef”,3                        输出：”XYZdefabc”</p>
<p><strong>思路：</strong> 先整体翻转变成  “fedZYXcba”.  在局部翻转  “fedZYX” 变成 “XYZdef” ，局部翻转 “cba” 变成 “abc”。 最终结果就变成了 “XYZdefabc”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(string&amp; str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-built_in">swap</span>(str[start], str[end]);<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">Reverse</span>(str, start, end);<br>    <span class="hljs-built_in">Reverse</span>(str, start, end-n);<br>    <span class="hljs-built_in">Reverse</span>(str, end-n+<span class="hljs-number">1</span>, end);<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="44-翻转单词序列"><a href="#44-翻转单词序列" class="headerlink" title="44.翻转单词序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&&tqId=11197&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">44.翻转单词序列</a></h2><p><strong>题目：</strong>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>示例：输入：”nowcoder. a am I”                        输出：”I am a nowcoder.”</p>
<p><strong>思路：</strong>此题与上一题是同一种类型都是先整体翻转，在局部翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-built_in">swap</span>(s[start], s[end]);<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> small = <span class="hljs-number">0</span>, big = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">Reverse</span>(str, <span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span> (small &lt; len) &#123;<br>        <span class="hljs-keyword">if</span> (str[small] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            small++;<br>            big++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[big] == <span class="hljs-string">&#x27; &#x27;</span> || str[big] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            <span class="hljs-built_in">Reverse</span>(str, small, --big);<br>            big++;<br>            small = big;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            big++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">45.扑克牌顺子</a></h2><p>**题目:**现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。<br>有如下规则：<br> 1.A为1，J为11，Q为12，K为13，A不能视为14<br> 2.大、小王为 0，0可以看作任意牌<br> 3.如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。<br>例如：给出数据[6,0,2,0,4]<br>中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]<br>这样这五张牌在[2,6]区间连续，输出true<br>数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]</p>
<p>示例：输入：[6,0,2,0,4]                    输出：true</p>
<p>​            输入：[0,3,2,6,4]                    输出：true</p>
<p>​            输入：[1,0,0,1,0]                    输出：false</p>
<p><strong>思路：</strong>统计指定的五张牌中零的个数和牌面花值得差值总和。如果牌面的花值总和大于零的个数，说明这副牌不是顺子。否则的话，这副牌是顺子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumOfZero</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers, <span class="hljs-keyword">int</span>&amp; start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; start &lt; numbers.<span class="hljs-built_in">size</span>(); start++) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[start] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        counter++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumOfBlank</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> small = start, big = small+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (big &lt; numbers.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[big] == numbers[small])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        counter += numbers[big] - numbers[small] <span class="hljs-number">-1</span>;<br>        small++;<br>        big++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-keyword">int</span>&gt; numbers )</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">empty</span>() || numbers.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> small = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> numberOfZero, numberOfblank;<br>    <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>    numberOfZero = <span class="hljs-built_in">GetNumOfZero</span>(numbers, small);<br>    numberOfBlank = <span class="hljs-built_in">GetNumOfBlank</span>(numbers, small);<br>    <span class="hljs-keyword">if</span> (numberOfBlank == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (numberOfBlank &gt; numberOfZero) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="46-孩子们的游戏-圆圈中最后剩下的数"><a href="#46-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="**46.孩子们的游戏(圆圈中最后剩下的数)"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**46.孩子们的游戏(圆圈中最后剩下的数)</a></h2><p><strong>题目：</strong>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<p>示例：输入：5,3                    输出：3</p>
<p><strong>思路：</strong>通过使用list数据结构模拟环形链表，当我们的迭代器指针指向了list 的尾部的时候。我们得将其移动到 头部位置这样才能形成环形。我们就在这样的环中不断的遍历来删除第 m-1 个结点，进而更新 list 直到list 的size 为 1 的时候。我们直接退出循环返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || m &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    list&lt;<span class="hljs-keyword">int</span>&gt;array;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    	array.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">auto</span> it = array.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span> (array.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            it++;<br>            <span class="hljs-keyword">if</span> (it == array.<span class="hljs-built_in">end</span>())<br>                it = array.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        list&lt;<span class="hljs-keyword">int</span>&gt;::iterator next = ++it;<br>        <span class="hljs-keyword">if</span> (next == array.<span class="hljs-built_in">end</span>())<br>            next = array.<span class="hljs-built_in">begin</span>();<br>        --it;<br>        array.<span class="hljs-built_in">erase</span>(*it);<br>        it = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (*it);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="**47.求1+2+3+…+n"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**47.求1+2+3+…+n</a></h2><p><strong>题目：</strong>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例：输入：5                        输出：15</p>
<p><strong>思路：</strong>通过调用构造函数实现循环累加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetSum</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">GetSum</span>() &#123;<br>		++times;<br>        sum += times;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        times = <span class="hljs-number">0</span>;<br>        sum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Getresult</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> times;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum;<br>&#125;;<br><br><span class="hljs-keyword">int</span> GetSum::times = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> GetSum::sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        GetSum::<span class="hljs-built_in">reset</span>();<br>        GetSum* obj = <span class="hljs-keyword">new</span> GetSum[n];<br>        <span class="hljs-keyword">delete</span> []obj;<br>        obj = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> GetSum::<span class="hljs-built_in">Getresult</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="**48.不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&&tqId=11201&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">**48.不用加减乘除做加法</a></h2><p><strong>题目：</strong>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>示例：输入：1,2                    输出：3</p>
<p><strong>思路：</strong>利用位运算实现加法，我们可以通过异或运算实现两个数的不进位加法。然后再通过与运算和左移运算实现相加后的进位运算，直至与运算和左移运算产生的结果为0.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">int</span> sum = num1 ^ num2;<br>        <span class="hljs-keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>        num1 = sum;<br>        num2 = carry;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (num2);<br>    <span class="hljs-keyword">return</span> num1;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&&tqId=11203&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">50.数组中重复的数字</a></h2><p><strong>题目：</strong>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p>
<p>示例：输入：[2,3,1,0,2,5,3]                            输出：2   说2或者3都对。</p>
<p><strong>思路：</strong>利用哈希表记录每个数字出现的次数，如果次数大于 1 直接返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hashTable;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =  <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (hashTable[numbrs[i]] &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> numbers[i];<br>        hashTable[numbrs[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


    </div>

    
    
    

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i>算法和数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/23/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-1/" rel="prev" title="剑指offer总结-1">
      <i class="fa fa-chevron-left"></i> 剑指offer总结-1
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/10/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-3/" rel="next" title="剑指offer总结-3">
      剑指offer总结-3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">第二次总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.1.</span> <span class="nav-text">4.重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">**17.树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F"><span class="nav-number">1.3.</span> <span class="nav-text">18.二叉树镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.</span> <span class="nav-text">22.从上往下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">1.5.</span> <span class="nav-text">**23.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E5%BE%97%E8%B7%AF%E5%BE%84"><span class="nav-number">1.6.</span> <span class="nav-text">**24.二叉树中和为某一值得路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">**26.二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">29.最小的K个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">1.9.</span> <span class="nav-text">30.连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">31.整数中1出现的次数(从1到n整数中1出现的次数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">1.11.</span> <span class="nav-text">**32.把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E4%B8%91%E6%95%B0"><span class="nav-number">1.12.</span> <span class="nav-text">33.丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.13.</span> <span class="nav-text">34.第一个只出现一次的字符位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">1.14.</span> <span class="nav-text">36.两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">1.15.</span> <span class="nav-text">**37.数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.16.</span> <span class="nav-text">38.二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.17.</span> <span class="nav-text">40.数组中只出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">1.18.</span> <span class="nav-text">**41.和为S的连续整数序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="nav-number">1.19.</span> <span class="nav-text">42.和为S的两个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.20.</span> <span class="nav-text">43.左旋转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97"><span class="nav-number">1.21.</span> <span class="nav-text">44.翻转单词序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="nav-number">1.22.</span> <span class="nav-text">45.扑克牌顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0"><span class="nav-number">1.23.</span> <span class="nav-text">**46.孩子们的游戏(圆圈中最后剩下的数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-%E6%B1%821-2-3-%E2%80%A6-n"><span class="nav-number">1.24.</span> <span class="nav-text">**47.求1+2+3+…+n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">1.25.</span> <span class="nav-text">**48.不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.26.</span> <span class="nav-text">50.数组中重复的数字</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XuZhang"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">XuZhang</p>
  <div class="site-description" itemprop="description">海阔凭鱼跃，天高任鸟飞</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuzhang1108" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xuzhang1108" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/bu-ke-zhi-wei-zhi" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;bu-ke-zhi-wei-zhi" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuzhang</span>
</div>

<!--添加运行时间-->
<span id="sitetime"></span>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		var t1 = Date.UTC(2021,05,14,12,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
