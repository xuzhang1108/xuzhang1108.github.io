<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuzhang1108.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一次小结：1. 二维数组中的查找题目：给你一个二维数组（注：数组的横向和纵向都是升序的）和一个数，让你写个函数判断这个数在不在二维数组中。例如下面的例子： [  [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15] ] 如果给的 target &#x3D; 7，则返回 true； 如果给的 target &#x3D; 3， 则返回 false； 思路： 遍历整个数组，当然可">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer总结-1">
<meta property="og:url" content="http://xuzhang1108.github.io/2021/05/23/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-1/index.html">
<meta property="og:site_name" content="XuZhang&#96;s blog">
<meta property="og:description" content="第一次小结：1. 二维数组中的查找题目：给你一个二维数组（注：数组的横向和纵向都是升序的）和一个数，让你写个函数判断这个数在不在二维数组中。例如下面的例子： [  [1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15] ] 如果给的 target &#x3D; 7，则返回 true； 如果给的 target &#x3D; 3， 则返回 false； 思路： 遍历整个数组，当然可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995">
<meta property="article:published_time" content="2021-05-23T12:40:05.000Z">
<meta property="article:modified_time" content="2021-06-25T02:35:43.745Z">
<meta property="article:author" content="XuZhang">
<meta property="article:tag" content="算法和数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995">

<link rel="canonical" href="http://xuzhang1108.github.io/2021/05/23/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>剑指offer总结-1 | XuZhang`s blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XuZhang`s blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuzhang1108.github.io/2021/05/23/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="XuZhang">
      <meta itemprop="description" content="海阔凭鱼跃，天高任鸟飞">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XuZhang`s blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指offer总结-1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-23 20:40:05" itemprop="dateCreated datePublished" datetime="2021-05-23T20:40:05+08:00">2021-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-25 10:35:43" itemprop="dateModified" datetime="2021-06-25T10:35:43+08:00">2021-06-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法和数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一次小结："><a href="#第一次小结：" class="headerlink" title="第一次小结："></a>第一次小结：</h1><h2 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">1. 二维数组中的查找</a></h2><p><strong>题目</strong>：给你一个二维数组（<strong>注：数组的横向和纵向都是升序的</strong>）和一个数，让你写个函数判断这个数在不在二维数组中。例如下面的例子：</p>
<p>[</p>
<p> [1,2,8,9],<br> [2,4,9,12],<br> [4,7,10,13],<br> [6,8,11,15]</p>
<p>]</p>
<p>如果给的 target = 7，则返回 true；</p>
<p>如果给的 target = 3， 则返回 false；</p>
<p><strong>思路：</strong> 遍历整个数组，当然可以找到结果，但是时间复杂度太高。因此，我们需要换一种方法。既然查找的过程就是比较，那么我们可不可以每次都取用<strong>固定位置的值</strong>和 target 进行比较呢。于是我们可以发现，如果我们使用右上角或左下角，会发现一个规律：就是比右上角小会排除他所在的列， 比右上角大会排除他所在的行。</p>
<p>以 target = 7 和取二维数组的右上角为例，当我们的 target 小于右上角的时候，说明 target 在右上角那个列的左边。因此我们可以排除掉此列 。此时数组变成了</p>
<p>[</p>
<p> [1,2,8],<br> [2,4,9],<br> [4,7,10],<br> [6,8,11]</p>
<p>]</p>
<p>因为我们与 target 进行比较使用的都是固定位置的值（也就是每次比较都使用右上角的值），于是我们选用8进行比较，发现 target 比他小，因此删除8所在的列。此时数组变成了</p>
<p>[</p>
<p> [1,2],<br> [2,4],<br> [4,7],<br> [6,8]</p>
<p>]</p>
<p>选用2和 target 进行比较 ，发现target 大于2，因此排除 2 所在的行。此时数组变成了</p>
<p>[<br> [2,4],<br> [4,7],<br> [6,8]</p>
<p>]</p>
<p>选用4和 target 进行比较 ，发现target 大于4，因此排除 4 所在的行。此时数组变成了</p>
<p>[<br> [4,7],<br> [6,8]</p>
<p>]</p>
<p>选用7和 target 进行比较 ，发现target 等于7，因此函数返回 true。</p>
<p>如果这样一遍遍的走下来，没有发现与 target 相等的值，我们返回 false。</p>
<p>整体流程是这样没错，那么我们如何用代码实现呢。我个人在代码实现阶段，卡在了我们这个循环的条件是啥，于是我就将 target = 3 这个例子带入到了 上方最后一个经过排除行和列的数组中。这时我就发现了循环条件了。当我们将 target = 3 和 7 比较 ，因为 3 小故排除了 7 所在的列。数组变成如下形式：</p>
<p>[<br> [4],<br> [6]</p>
<p>]</p>
<p>选用4和 target = 3 进行比较 ，发现target 小于4，因此排除 4 所在的列。此时数组变成了空数组，因此我们就无法查找下去了。故我们的 ==列数要大于等于0==。==同理行数要小于等于行的长度减-1==。 </p>
<p>综上，形成如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; array)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>    <br>    <span class="hljs-keyword">int</span> col = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, row = array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> initCol = col, initRow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (initCol &gt;= <span class="hljs-number">0</span> &amp;&amp; initRow &lt;= row) &#123;  <span class="hljs-comment">//保证遍历的数组不能因为initCol和initRow变化而为空</span><br>        <span class="hljs-keyword">if</span> (array[initRow][initCol] &gt; target) &#123;<br>            initCol--;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[initRow][initCol] &lt; target) &#123;<br>            initRow++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>     <br></code></pre></td></tr></table></figure>

<h2 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tqId=11155&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">2. 替换空格</a></h2><p><strong>题目：</strong> 将给定的字符串中的空格使用 %20 替换。</p>
<p> 示例：输入： We are happy         输出： We%20are%20happy</p>
<p><strong>思路：</strong>读完题目后，大概的想法就是从前往后遍历遇到空格就将其替换成%20。但是细想之后，你会发现从前往后这样遇到空格就用%20替代的时间复杂度还是挺大的。因为你每一次遇到空格都要将空格后面的所用元素都移动一遍。所以我们可不可以倒着进行遍历再填充呢，如果我们通过双指针确实可以实现啊。首先，我们遍历字符串确定空格的数目。因为有一个空格，我们填充后的字符串就会多两个字符。所以我们要将我们输入的字符串进行 resize 操作。resize的大小 = 原始字符串的长度 + 空格数*2 。然后，我们要初始化两个索引值。一个指向原来字符串的末尾，另一个指向扩充后的字符串末尾。所有，基本工作做完了。我们就要从前往后遍历数组了，如果前一个索引值遇到空格，我们就在后一个索引值的位置进行填充工作。直到前一个索引值与后一个索引值相遇，我们退出循环返回结果。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> numBlank = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (len = <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>            numBlank++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> resizeLen = len + <span class="hljs-number">2</span>*numBlank;<br>    s.<span class="hljs-built_in">resize</span>(resizeLen);<br>    <br>    <span class="hljs-keyword">int</span> oldTail = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> newTail = resizeLen - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (oldTail &lt; newTail) &#123;<br>        <span class="hljs-keyword">if</span> (s[oldTail] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-comment">//s[newTail++] = &#x27;0&#x27;;     // 我也是醉了， 我在编辑代码时怎么想的让其往后跑呢，这个低级错误犯得。</span><br>            <span class="hljs-comment">//s[newTail++] = &#x27;2&#x27;;</span><br>            <span class="hljs-comment">//s[newTail++] = &#x27;%&#x27;;</span><br>            s[newTail--] = <span class="hljs-string">&#x27;0&#x27;</span>;     <span class="hljs-comment">// 我也是醉了， 我在编辑代码时怎么想的让其往后跑呢，这个低级错误犯得。</span><br>            s[newTail--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            s[newTail--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            s[newTail] = s[oldTail];<br>            newTail--;<br>        &#125;<br>        oldTail--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">3. 从尾到头打印链表</a></h2><p><strong>题目：</strong>给你一个链表，将链表的值从尾到头将值打印出来。</p>
<p>示例：输入：{67,0,24,58}           输出： {58,24,0,67}</p>
<p><strong>思路：</strong>通过逆序打印，我们可以联想到栈的后进先出特性。因此我们可以通过栈先将每一个节点压入栈中，所有节点压入完成后。我们在进行弹栈的操作，这样就完成了从尾到头打印链表。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;   <span class="hljs-comment">//如果头结点是空，直接放回。</span><br>    <br>    stack&lt;ListNode*&gt;nodeStack;<br>    ListNode *node = head;<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        nodeStack.<span class="hljs-built_in">push</span>(node);<br>        node = node-&gt;next;<br>	&#125;<br>    <br>    <span class="hljs-keyword">while</span>(!nodeStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        ListNode *tempNode = nodeStack.<span class="hljs-built_in">top</span>();<br>        ans.<span class="hljs-built_in">push_back</span>(tempNode-&gt;val);<br>        nodeStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">5. 用两个栈实现队列</a></h2><p><strong>题目</strong>：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>思路：</strong> 首先，栈的特性是 后进先出。队列的特性是 先进先出。因此通过两个 后进先出 的栈 可以实现 一个队列的先进先出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack1.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">int</span> temp = stack1.<span class="hljs-built_in">top</span>();<br>                stack2.<span class="hljs-built_in">push</span>(temp);<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = stack2.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">//卡到此处了，我直接就 return stack2.top() 没有进行stack2弹栈这一操作，导致输出结果一样的 </span><br>        stack2.<span class="hljs-built_in">pop</span>();            <span class="hljs-comment">//看了书才发觉哪里错了 唉</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="**6. 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**6. 旋转数组的最小数字</a></h2><p><strong>题目：</strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<p>示例：输入：[3,4,5,1,2]                                返回值：1</p>
<p><strong>思路：</strong>通过<strong>输入一个非递减排序的数组</strong> （看到给定顺序的序列，就想二分法是否可以使用啊）我们知道使用二分法。首先，我们设置两个索引，一个指向头，一个指向尾。然后，我们再取中间的数 也就是 5. 因为这是个旋转数组所以开头和末尾的值有可能相等或末尾小于开头。所以当我们的中间值大于前一个索引值时意味着最小值在 中间值的后面，于是我们将前一个索引值设成现在的中间值。再在现在的两个索引间求中间值，即 midNum = 1.因为 1 小于尾部索引的值 故将尾部索引指向现在的 midNum 的索引。经过这样的循环过程，前一个索引一定指到前一个递增数组的末尾，后一个索引一定指向后一个递增数组的头部。此时可以跳出循环，即tail-head == 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tail = rotateArray.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> midIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (head &lt; tail) &#123;<br>        <span class="hljs-comment">//经过这样的循环过程，前一个索引一定指到前一个递增数组的末尾，后一个索引一定指向后一个递增数组的头部,故 tail-head == 1.</span><br>        <span class="hljs-keyword">if</span> (tail - head == <span class="hljs-number">1</span>) &#123;  <br>            midIndex = tail;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        midIndex = (head + tail) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (rotateArray[midIndex] &gt; rotateArray[head])<br>            head = midIndex;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotateArray[midIndex] &lt; rotateArray[tail])<br>            tail = midIndex; <br>    &#125;<br>    <span class="hljs-keyword">return</span> rotateArray[midIndex];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">7. 斐波那契数列</a></h2><p><strong>题目：</strong>现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）</p>
<p><strong>思路</strong>：动态规划五部曲</p>
<p>1.定义dp数组，在dp数组中 dp[i]的意思是斐波那契的第n项值是多少。</p>
<p>2.找到递推公式，dp[i] = dp[i-1] + dp[i-2]</p>
<p>3.初始化 dp[0] = 0, dp[1] = 1</p>
<p>4.遍历顺序，有递推公式可知，顺序使从前往后遍历的。</p>
<p>5.验证过程，如果与预期不同，进行验证。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;=n; i++) &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8. 跳台阶"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">8. 跳台阶</a></h2><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p>
<p><strong>思路：</strong>同上面的斐波那契数列，此题相当于斐波那契的实际应用题。只是此题的初始值设置，不同于上面的斐波那契。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;=n; i++) &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9. 变态跳台阶"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">9. 变态跳台阶</a></h2><p><strong>题目：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>思路：</strong>通过数学归纳法可知，n级台阶有$2^n-1$种方法。</p>
<h2 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10. 矩形覆盖"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">10. 矩形覆盖</a></h2><p>题目：我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20201028/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995" alt="img"></p>
<p>思路：通过n = 1时，有1种方法</p>
<p>​            n = 2时，有2种方法</p>
<p>​            n = 3时，有3种方法</p>
<p>可知，这又是斐波那契的实际应用题。于是应用动态规划五部曲，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>   vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>   dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>   dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;=n; i++) &#123;<br>       dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>   &#125;<br>   <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="11-二进制中一的个数"><a href="#11-二进制中一的个数" class="headerlink" title="11. 二进制中一的个数"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">11. 二进制中一的个数</a></h2><p><strong>题目</strong>：输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>示例：    输入：10    返回值：2。</p>
<p><strong>思路：</strong> 我们可以通过将给定的数值通过与运算和给定的数值减1进行与操作，来判断整数中含有1的个数。 例如10的二进制为1010，当我们-1操作后，变为1001.将1001再与1010进行与操作得到1000.再将值赋予给输入值，循环此操作来判断1的个数。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n = n &amp; (n<span class="hljs-number">-1</span>);<br>        ans++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="**12. 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**12. 数值的整数次方</a></h2><p><strong>题目：</strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</p>
<p>示例：    输入：2.00000,3     返回值：8.00000            输入：2.10000,3    返回值：9.26100</p>
<p><strong>思路：</strong>此题注意点应是 当base = 0， exponent = 负数的时候，并且base != 0 , exponent = 负数时也是值得注意的。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>	<span class="hljs-keyword">double</span> ans = <span class="hljs-number">1.0</span>;  <br>    <span class="hljs-keyword">if</span> (base == <span class="hljs-number">0.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span> (base == <span class="hljs-number">1.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= -exponent; i++) &#123;<br>            ans *= base;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= exponent; i++) &#123;<br>            ans *= base;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>)<br>        ans = <span class="hljs-number">1.0</span> / ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;    <br></code></pre></td></tr></table></figure>

<h2 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="**13. 调整数组顺序使奇数位于偶数前面"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**13. 调整数组顺序使奇数位于偶数前面</a></h2><p><strong>题目</strong>：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有            的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>示例：输入：[1,2,3,4]    返回值：[1,3,2,4]。                    输入：[2,4,6,5,7]       返回值：[5,7,2,4,6]</p>
<p><strong>思路</strong>：这只是<strong>满足条件一</strong>的想法：利用双指针来实现调换位置，一个指针指向开头，一个指向末尾。当前一个指针指向的是奇数时，将前一个指针往后移动，直到遇到的是偶数停止移动。若后一个指针指向的是偶数，使该指针往前移动，直到遇到的数是奇数。综上，当前一个指针指向的是偶数，后一个指针指向的是奇数，我们调换两个数的位置。依次循环执行这个过程，直到前一个指针和后一个指针相遇。跳出循环，返回结果。</p>
<p><strong>更改思路</strong>： 在仔细看一下给定的输入是有特点的，奇数和偶数的相对顺序都是升序的。于是我们可以开辟一个空间先进行奇数的拷贝，再进行偶数的拷贝。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 未认真读题啊 “并保证奇数和奇数，偶数和偶数之间的相对位置不变”，下面的代码只是保证了所有的偶数位于数组的后半部分的这个条件。但是没有满足奇数和奇数，偶数和偶数之间的相对位置不变。</span><br><span class="hljs-comment">vector&lt;int&gt; reOrderArray(vector&lt;int&gt;&amp; array) &#123;</span><br><span class="hljs-comment">	if (array.empty()) return &#123;&#125;;</span><br><span class="hljs-comment">    int len = array.size();</span><br><span class="hljs-comment">    int tail = len - 1;</span><br><span class="hljs-comment">    int head = 0;</span><br><span class="hljs-comment">    while (head &lt; tail) &#123;</span><br><span class="hljs-comment">        if (array[head] &amp; 0x1 == 1)</span><br><span class="hljs-comment">            head++;</span><br><span class="hljs-comment">        if (array[tail] &amp; 0x1 == 0)</span><br><span class="hljs-comment">            tail--;</span><br><span class="hljs-comment">        if (!(array[head] &amp; 0x1) &amp;&amp; (array[tail] &amp; 0x1)) &#123;</span><br><span class="hljs-comment">            swap(array[head++], array[tail--]);     </span><br><span class="hljs-comment">		&#125;       </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return array;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br>正确代码<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">ans</span>(array.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] % <span class="hljs-number">2</span>)<br>            ans[index++] = array[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (!(array[i] % <span class="hljs-number">2</span>))<br>            ans[index++] = array[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="14-链表中倒数第K个结点"><a href="#14-链表中倒数第K个结点" class="headerlink" title="14. 链表中倒数第K个结点"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">14. 链表中倒数第K个结点</a></h2><p><strong>题目：</strong>输入一个链表，输出该链表中倒数第k个结点。如果该链表长度小于k，请返回空。</p>
<p>示例：输入：{1,2,3,4,5},1         返回值：{5}</p>
<p><strong>思路</strong>：利用快慢指针来实现查找链表的第K个结点。在开始的时候，将快慢指针都初始化为指向头结点。然后让快指针先走K个结点。当快指针到达后与慢指针相距K个距离的结点的时候，我们同时移动快慢指针，当快指针为空的时候，结束循环，返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    ListNode *fastNode = pHead;<br>    ListNode *slowNode = pHead；<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-comment">//此处又犯了个低级错误，将已经声明过的变量又声明了一遍。 我的错误：ListNode *fastNode = fast—&gt;next;</span><br>        fastNode = fastNode-&gt;next;            <br>        <span class="hljs-keyword">if</span> (fastNode == <span class="hljs-literal">nullptr</span> &amp;&amp; k != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fastNode != <span class="hljs-literal">nullptr</span>) &#123;<br>        fastNode = fastNode-&gt;next;<br>        slowNode = slowNode-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slowNode; <br>&#125;    <br></code></pre></td></tr></table></figure>

<h2 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15. 反转链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">15. 反转链表</a></h2><p><strong>题目</strong>：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>示例：输入：{1,2,3}        返回值：{3,2,1}</p>
<p><strong>思路：</strong> 利用双指针的想法，先创建个dummyHead和preNode分别指向空和头结点。然后遍历链表，循环退出的条件是preNode不为空。在循环体中将prevNode的下一个结点保存为临时的node。然后再将用dummyNode对preNode-&gt;next 进行赋值。之后再将preNode赋值给dummyNode。tempNode赋值给preNode。循环执行此过程。当preNode指向空的时候，退出循环，返回结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    ListNode *preNode = pHead;<br>    ListNode *dummyNode = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (preNode != <span class="hljs-literal">nullptr</span>) &#123;<br>        ListNode *tempNode = preNode-&gt;next;<br>        preNode-&gt;next = dummyNode;<br>        dummyNode = preNode;<br>        preNode = tempNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyNode;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="**16. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**16. 合并两个排序的链表</a></h2><p><strong>题目：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>示例：输入：{1,3,5},{2,4,6}        返回值：{1,2,3,4,5,6}</p>
<p><strong>思路：</strong>当我们得到两个链表中较小的头结点并把它链接到已经合并的链表之后，两个链表剩余的结点依然是排序的，因此合并的步骤和之前的步骤一样。这就是典型的递归过程。</p>
<p>![](C:\Users\Xu Zhang\Pictures\Saved Pictures\屏幕截图 2021-05-23 200414.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead2;<br>    <span class="hljs-keyword">if</span> (pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead1;<br>   	<br>    ListNode *MergeHead = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>        MergeHead = pHead1;<br>        MergeHead-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1-&gt;next, pHead2);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        MergeHead = pHead2;<br>        MergeHead-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1, pHead2-&gt;next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> MergeHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="**19. 顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**19. 顺时针打印矩阵</a></h2><p><strong>题目：</strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>示例： 输入：[[1,2],[3,4]]</p>
<p>​            返回值：[1,2,4,3]</p>
<p><strong>思路：</strong>我们执行如下图的矩阵遍历过程，我们第一圈开始的位置是（0，0），第二圈<strong>（最后一圈）</strong>开始的位置是（1, 1）。如果这是个5X5的矩阵我们第一圈开始的位置是（0，0），第二圈开始的位置是（1, 1），第三圈<strong>（最后一圈）</strong>开始的位置是（2，2）。此时我们会发现结束遍历矩阵的条件是( columns&gt;2 * start) &amp;&amp; (rows&gt;2*start). 于是我们就可以模拟整个过程了，但是模拟的过程中还会涉及边界条件判断。</p>
<p>![](C:\Users\Xu Zhang\Pictures\Saved Pictures\屏幕截图 2021-05-23 151507.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;ans;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> startX = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> startY = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> endX = cols<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> endY = rows<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (cols &gt; <span class="hljs-number">2</span>*startX &amp;&amp; rows &gt; <span class="hljs-number">2</span>*startY) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = startX; i &lt;= endX; i++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(matrix[startY][i]);<br>        &#125;<br>        <br>        <span class="hljs-comment">/* 这次遍历开始加判断条件是因为，你要判断他是否还有下一行。如果输入的矩阵是个行向量，此块代码肯定不能执行啊。因为此块的代码是执行从上往下遍历的，你既		   然都没有下一行了，我还执行什么。*/</span><br>        <span class="hljs-keyword">if</span> (startY &lt; endY) &#123;            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = startY+<span class="hljs-number">1</span>; i &lt;= endY; i++) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[i][endX]);<br>            &#125; <br>        &#125;<br>        <br>        <span class="hljs-comment">/* 这块的代码是在矩阵中新的一行执行从右往左的遍历。 start &lt; endY 还是判断有没有新的一行  startX &lt; endX 判断从右往左还有没有可以遍历的列*/</span><br>        <span class="hljs-keyword">if</span> (startX &lt; endX &amp;&amp; startY &lt; endY) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = endX<span class="hljs-number">-1</span>; i &gt;= startX; i--) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[endY][i]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">/* 这块代码是从一列从下往上做遍历。 startX &lt; endX 可以排除当传入的矩阵是列向量而做重复于第二个for循环的操作*/</span><br>        <span class="hljs-keyword">if</span>(startX &lt; endX &amp;&amp; startY &lt; endY<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = endY<span class="hljs-number">-1</span>; i &gt; startY; i--) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[i][start]);<br>            &#125;<br>        &#125;<br>        startX++;<br>        startY++;<br>        endX--;<br>        endY--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">20. 包含min函数的栈</a></h2><p><strong>题目：</strong>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 函数的时间复杂度都是 O(1).</p>
<p>push(value)：将元素 value压入栈中</p>
<p>pop()：弹出栈顶的元素</p>
<p>top() ：获得栈顶元素</p>
<p>min() ：获得栈中的最小元素。</p>
<p>示例:</p>
<p>输入:<br>[“PSH-1”,”PSH2”,”MIN”,”TOP”,”POP”,”PSH1”,”TOP”,”MIN”]</p>
<p>输出:-1,2,1,-1</p>
<p>解释如下:</p>
<p>“PSH-1”:  将元素-1压入栈中，栈中元素为-1</p>
<p>”PSH2”:  将元素2压入栈中，栈中元素为2, -1</p>
<p>“MIN”：  获取最小的元素 ==&gt;输出-1</p>
<p>“TOP”:    获得栈顶元素 ==&gt;输出2</p>
<p>“POP”:   弹出栈顶元素，即弹出2，栈中元素为-1</p>
<p>“PSH1”： 将元素1压入栈中，栈中元素为1，-1</p>
<p>“TOP”:   获得栈顶元素 ==&gt;输出1</p>
<p>“MIN”：  获取最小的元素 ==&gt;输出-1</p>
<p><strong>思路：</strong> 通过两个栈来实现包含min函数的栈，一个用于存储数据，另一个作为辅助栈来保存数据栈中的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">empty</span>() || stack1.<span class="hljs-built_in">top</span>() &lt;= stack2.<span class="hljs-built_in">top</span>())<br>            stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">pop</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = stack2.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt;stack1;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt;stack2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="21-栈的压入，-弹出序列"><a href="#21-栈的压入，-弹出序列" class="headerlink" title="**21. 栈的压入， 弹出序列"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">**21. 栈的压入， 弹出序列</a></h2><p><strong>题目：</strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<p>示例：输入：[1,2,3,4,5],[4,3,5,1,2]            返回值：false</p>
<p><strong>思路：</strong> 建立辅助栈，把输入的第一个序列中的数字依次压入到辅助栈中，并按照第二个序列的顺序依次从辅助栈中弹出数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pushV,vector&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!pushV.<span class="hljs-built_in">empty</span>() &amp;&amp; !popV.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> startPush = <span class="hljs-number">0</span>, lenPush = pushV.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> startPop = <span class="hljs-number">0</span>, lenPop = popV.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-keyword">int</span>&gt;auxiliaryStack;<br>        <span class="hljs-keyword">while</span> (startPop &lt; lenPop) &#123;<br>            <span class="hljs-keyword">while</span> (auxiliaryStack.<span class="hljs-built_in">empty</span>() || auxiliaryStack.<span class="hljs-built_in">top</span>() != popV[startPop]) &#123;<br>                <span class="hljs-keyword">if</span> (startPush == lenPush) <br>                    <span class="hljs-keyword">break</span>;<br>                auxiliaryStack.<span class="hljs-built_in">push</span>(pushV[startPush]);<br>                startPush++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (auxiliaryStack.<span class="hljs-built_in">top</span>() != popV[startPop])<br>                <span class="hljs-keyword">break</span>;<br>            auxiliaryStack.<span class="hljs-built_in">pop</span>();<br>            startPop++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (auxiliaryStack.<span class="hljs-built_in">empty</span>() &amp;&amp; startPop == lenPop)<br>            ans = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25. 复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">25. 复杂链表的复制</a></h2><p>题目：输入一个复杂链表，如下图所示：（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>![](C:\Users\Xu Zhang\Pictures\Saved Pictures\屏幕截图 2021-05-23 180904.png)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 复杂链表的数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RandomListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> label;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RandomListNode</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">random</span>;</span><br>    <span class="hljs-built_in">RandomListNode</span>(<span class="hljs-keyword">int</span> x) :<br>            <span class="hljs-built_in">label</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">random</span>(<span class="hljs-literal">NULL</span>) &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>思路:我们可以将复制的过程分为三个步骤：</p>
<p>1.进行原始链表的结点复制，使其变成  </p>
<p>![](C:\Users\Xu Zhang\Pictures\Saved Pictures\屏幕截图 2021-05-23 181814.png)</p>
<p>2.我们将其原始结点上的random指针也进行相应的复制。如下图所示：</p>
<p>![](C:\Users\Xu Zhang\Pictures\Saved Pictures\屏幕截图 2021-05-23 182047.png)</p>
<ol start="3">
<li>将复制的结点与原始的结点进行分割，使其成为独立的一个链表。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 进行链表结点的复制</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyNode</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>        RandomListNode* tempNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(pHead-&gt;label);<br>        tempNode-&gt;next = pHead-&gt;next;<br>        pHead-&gt;next = tempNode;<br>        pHead = tempNode-&gt;next;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 进行random指针的复制</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connectNode</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>    RandomListNode* node = pHead;<br>    RandomListNode* copyNode = pHead-&gt;next;<br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;random == <span class="hljs-literal">nullptr</span>) &#123;<br>            node = copyNode-&gt;next;<br>            copyNode = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            copyNode-&gt;random = node-&gt;random-&gt;next;<br>            node = copyNode-&gt;next;<br>            copyNode = node-&gt;next;<br>        &#125;  <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 切分复制好的完整链表</span><br><span class="hljs-function">RandomListNode* <span class="hljs-title">reconnectNode</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>    RandomListNode* initHead = pHead;<br>    RandomListNode* copyHead = <span class="hljs-literal">nullptr</span>;<br>    RandomListNode* copyNode = <span class="hljs-literal">nullptr</span>;<br>    copyHead = copyNode = initHead-&gt;next;<br>    initHead-&gt;next = copyNode-&gt;next;<br>    initHead = initHead-&gt;next;<br>   <br>    <span class="hljs-keyword">while</span> (initHead != <span class="hljs-literal">nullptr</span>) &#123;<br>        copyNode-&gt;next = initHead-&gt;next;<br>    	copyNode =  copyNode-&gt;next;<br>        initHead-&gt;next = copyNode-&gt;next;<br>        initHead = initHead-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> copyHead;<br>&#125;<br><br><span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">copyNode</span>(pHead);<br>    <span class="hljs-built_in">connectNode</span>(pHead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reconnectNode</span>(pHead);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28. 数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&tab=answerKey">28. 数组中出现次数超过一半的数字</a></h2><p><strong>题目：</strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1&lt;=数组长度&lt;=50000</p>
<p>示例： 输入：[1,2,3,2,2,2,5,4,2]    返回值：2        </p>
<p>​             输入：[3,3,3,3,2,2,2]          返回值：3   </p>
<pre><code>         输入：[1]                             返回值：1
</code></pre>
<p><strong>思路：</strong>利用数字超过数组一半这个特性，我们可以知道超过数组一半的这个数字个数一定大于其他数字的数目的总和。于是我们通过times来查找超过数组一半长度的这个数字。首先，我们将结果设定为数组的首个元素并将其的times设为1. 如果下一个数与其相同就将其的 times++，否则将 times–。当times–到 0 时，将当前结果用下一个数来替代。循环往复此过程，最终的结果一定是超过数组长度一半的那个数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (numbers.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> result = numbers[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> times = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (result == numbers[i]) &#123;<br>            times++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            times--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (times == <span class="hljs-number">0</span>) &#123;<br>            result = numbers[i];<br>            times = <span class="hljs-number">1</span>;<br>        &#125;       <br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>


    </div>

    
    
    

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i>算法和数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/16/Linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" rel="prev" title="Linux-基本命令">
      <i class="fa fa-chevron-left"></i> Linux-基本命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/31/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93-2/" rel="next" title="剑指offer总结-2">
      剑指offer总结-2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">第一次小结：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.1.</span> <span class="nav-text">1. 二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.2.</span> <span class="nav-text">2. 替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">3. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.4.</span> <span class="nav-text">5. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">1.5.</span> <span class="nav-text">**6. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">1.6.</span> <span class="nav-text">7. 斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">1.7.</span> <span class="nav-text">8. 跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">1.8.</span> <span class="nav-text">9. 变态跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-number">1.9.</span> <span class="nav-text">10. 矩形覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%E4%B8%80%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">11. 二进制中一的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">1.11.</span> <span class="nav-text">**12. 数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">1.12.</span> <span class="nav-text">**13. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">1.13.</span> <span class="nav-text">14. 链表中倒数第K个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.14.</span> <span class="nav-text">15. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.15.</span> <span class="nav-text">**16. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">1.16.</span> <span class="nav-text">**19. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">1.17.</span> <span class="nav-text">20. 包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%EF%BC%8C-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">1.18.</span> <span class="nav-text">**21. 栈的压入， 弹出序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">1.19.</span> <span class="nav-text">25. 复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.20.</span> <span class="nav-text">28. 数组中出现次数超过一半的数字</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XuZhang"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">XuZhang</p>
  <div class="site-description" itemprop="description">海阔凭鱼跃，天高任鸟飞</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuzhang1108" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xuzhang1108" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/bu-ke-zhi-wei-zhi" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;bu-ke-zhi-wei-zhi" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>知乎</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuzhang</span>
</div>

<!--添加运行时间-->
<span id="sitetime"></span>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* 
		Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数
        */
		var t1 = Date.UTC(2021,05,14,12,00,00); //北京时间2018-2-13 00:00:00
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+/*diffYears+" 年 "+*/diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
